// === Core Slim Mode (recommended starting point) ===
// Keep only the minimum to prove login works smoothly on Replit.
// When ready, re-enable the commented imports/routes in index.ts and copy over the extra routers.

# Repo layout
```
passpilot/
├─ package.json
├─ tsconfig.json
├─ .env.example
├─ drizzle.config.ts
├─ drizzle/
│  └─ migrations/            # generated by drizzle-kit
└─ src/
   ├─ server/
   │  ├─ index.ts
   │  ├─ db/
   │  │  ├─ client.ts
   │  │  └─ schema.ts
   │  ├─ middleware/
   │  │  ├─ asyncHandler.ts
   │  │  ├─ error.ts
   │  │  ├─ auth.ts
   │  │  ├─ tenant.ts
   │  │  └─ rateLimit.ts
   │  ├─ services/
   │  │  ├─ users.ts
   │  │  ├─ schools.ts
   │  │  └─ passes.ts
   │  └─ routes/
   │     ├─ public.ts
   │     ├─ auth.ts
   │     ├─ admin.ts
   │     ├─ kiosk.ts
   │     ├─ passes.ts
   │     └─ sa.ts
   └─ scripts/
      └─ seed.ts
```

---

## package.json
```json
{
  "name": "passpilot-starter",
  "version": "0.1.0",
  "type": "module",
  "scripts": {
    "dev": "tsx src/server/index.ts",
    "build": "tsc -p .",
    "start": "node dist/server/index.js",
    "db:generate": "drizzle-kit generate:pg",
    "db:migrate": "drizzle-kit migrate",
    "db:studio": "drizzle-kit studio",
    "seed": "tsx src/scripts/seed.ts"
  },
  "dependencies": {
    "bcryptjs": "^2.4.3",
    "cookie": "^0.6.0",
    "cookie-parser": "^1.4.6",
    "dotenv": "^16.4.5",
    "drizzle-orm": "^0.33.0",
    "express": "^4.19.2",
    "helmet": "^7.1.0",
    "pg": "^8.12.0",
    "zod": "^3.23.8"
  },
  "devDependencies": {
    "@types/express": "^4.17.21",
    "@types/cookie-parser": "^1.4.7",
    "@types/node": "^20.11.0",
    "drizzle-kit": "^0.24.0",
    "tsx": "^4.19.2",
    "typescript": "^5.4.5"
  }
}
```

---

## tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES2020",
    "module": "ESNext",
    "moduleResolution": "Bundler",
    "esModuleInterop": true,
    "forceConsistentCasingInFileNames": true,
    "skipLibCheck": true,
    "strict": true,
    "outDir": "dist",
    "rootDir": "src"
  },
  "include": ["src/**/*"]
}
```

---

## .env.example
```
NODE_ENV=production
DATABASE_URL=postgres://user:pass@host:5432/dbname
SESSION_SECRET=replace_me
```

---

## drizzle.config.ts
```ts
import { defineConfig } from 'drizzle-kit';

export default defineConfig({
  schema: './src/server/db/schema.ts',
  out: './drizzle/migrations',
  dialect: 'postgresql',
  dbCredentials: { url: process.env.DATABASE_URL ?? '' }
});
```

---

## src/server/db/schema.ts
```ts
import { pgTable, serial, varchar, boolean, integer, timestamp, text } from 'drizzle-orm/pg-core';
import { relations } from 'drizzle-orm';

export const schools = pgTable('schools', {
  id: serial('id').primaryKey(),
  name: varchar('name', { length: 120 }).notNull(),
  seatsAllowed: integer('seats_allowed').notNull().default(50),
  active: boolean('active').notNull().default(true),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull()
});

export type Role = 'teacher' | 'admin' | 'superadmin';

export const users = pgTable('users', {
  id: serial('id').primaryKey(),
  email: varchar('email', { length: 255 }).notNull().unique(),
  passwordHash: varchar('password_hash', { length: 255 }).notNull(),
  role: varchar('role', { length: 20 }).notNull(),
  schoolId: integer('school_id').references(() => schools.id).notNull(),
  active: boolean('active').notNull().default(true),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull()
});

export const kioskDevices = pgTable('kiosk_devices', {
  id: serial('id').primaryKey(),
  schoolId: integer('school_id').references(() => schools.id).notNull(),
  room: varchar('room', { length: 80 }).notNull(),
  pinHash: varchar('pin_hash', { length: 255 }).notNull(),
  token: varchar('token', { length: 255 }).notNull().unique(),
  active: boolean('active').notNull().default(true),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull()
});

export const passes = pgTable('passes', {
  id: serial('id').primaryKey(),
  studentName: varchar('student_name', { length: 140 }).notNull(),
  reason: varchar('reason', { length: 200 }).notNull(),
  issuedByUserId: integer('issued_by_user_id').references(() => users.id).notNull(),
  schoolId: integer('school_id').references(() => schools.id).notNull(),
  status: varchar('status', { length: 20 }).notNull().default('active'),
  startsAt: timestamp('starts_at', { withTimezone: true }).defaultNow().notNull(),
  endsAt: timestamp('ends_at', { withTimezone: true })
});

export const audits = pgTable('audits', {
  id: serial('id').primaryKey(),
  actorUserId: integer('actor_user_id').references(() => users.id),
  schoolId: integer('school_id'),
  action: varchar('action', { length: 80 }).notNull(),
  targetType: varchar('target_type', { length: 40 }).notNull(),
  targetId: integer('target_id'),
  data: text('data'),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull()
});

export const usersRelations = relations(users, ({ one }) => ({
  school: one(schools, { fields: [users.schoolId], references: [schools.id] })
}));
```

---

## src/server/db/client.ts
```ts
import 'dotenv/config';
import { drizzle } from 'drizzle-orm/node-postgres';
import { Pool } from 'pg';

const pool = new Pool({ connectionString: process.env.DATABASE_URL });
export const db = drizzle(pool);
```

---

## src/server/middleware/asyncHandler.ts
```ts
import type { Request, Response, NextFunction } from 'express';

export const asyncHandler = (fn: any) => (req: Request, res: Response, next: NextFunction) => {
  Promise.resolve(fn(req, res, next)).catch(next);
};
```

---

## src/server/middleware/error.ts
```ts
import type { ErrorRequestHandler, RequestHandler } from 'express';

export const notFound: RequestHandler = (req, res) => {
  res.status(404).json({ error: 'Not Found' });
};

export const errorHandler: ErrorRequestHandler = (err, req, res, _next) => {
  const status = (err as any).status || 500;
  if (process.env.NODE_ENV !== 'production') {
    console.error(err);
  }
  res.status(status).json({ error: 'Server Error', detail: process.env.NODE_ENV === 'production' ? undefined : String(err) });
};
```

---

## src/server/middleware/auth.ts
```ts
import type { Request, Response, NextFunction } from 'express';
import cookieParser from 'cookie-parser';
import crypto from 'crypto';

// Simple signed cookie session (httpOnly). No JWT/Redis required.
const COOKIE_NAME = 'pp_sess';
const ALGO = 'sha256';

export function cookies(secret: string) {
  return cookieParser(secret);
}

export type Session = {
  userId: number;
  schoolId: number;
  role: 'teacher' | 'admin' | 'superadmin';
  iat: number;
};

export function sign(value: string, secret: string) {
  const sig = crypto.createHmac(ALGO, secret).update(value).digest('base64url');
  return `${value}.${sig}`;
}

export function verify(signed: string, secret: string) {
  const [value, sig] = signed.split('.');
  if (!value || !sig) return null;
  const expected = crypto.createHmac(ALGO, secret).update(value).digest('base64url');
  return crypto.timingSafeEqual(Buffer.from(sig), Buffer.from(expected)) ? value : null;
}

export function setSession(res: Response, session: Session) {
  const secret = process.env.SESSION_SECRET!;
  const value = Buffer.from(JSON.stringify(session)).toString('base64url');
  const signed = sign(value, secret);
  res.cookie(COOKIE_NAME, signed, {
    httpOnly: true,
    sameSite: 'lax',
    secure: 'auto',
    maxAge: 1000 * 60 * 60 * 8 // 8 hours
  });
}

export function clearSession(res: Response) {
  res.cookie(COOKIE_NAME, '', { httpOnly: true, sameSite: 'lax', secure: 'auto', maxAge: 0 });
}

export function readSession(req: Request): Session | null {
  const secret = process.env.SESSION_SECRET!;
  const raw = req.signedCookies?.[COOKIE_NAME];
  if (!raw) return null;
  const value = verify(raw, secret);
  if (!value) return null;
  try {
    const json = JSON.parse(Buffer.from(value, 'base64url').toString('utf8')) as Session;
    return json;
  } catch {
    return null;
  }
}

export function requireAuth(req: Request, res: Response, next: NextFunction) {
  const s = readSession(req);
  if (!s || !s.userId || !s.schoolId) return res.status(401).json({ error: 'Unauthorized' });
  (req as any).user = s;
  next();
}

export function requireRole(role: 'admin' | 'superadmin') {
  return (req: Request, res: Response, next: NextFunction) => {
    const u = (req as any).user as Session | undefined;
    if (!u) return res.status(401).json({ error: 'Unauthorized' });
    if (role === 'admin' && !['admin', 'superadmin'].includes(u.role)) return res.status(403).json({ error: 'Forbidden' });
    if (role === 'superadmin' && u.role !== 'superadmin') return res.status(403).json({ error: 'Forbidden' });
    next();
  };
}
```

---

## src/server/middleware/tenant.ts
```ts
import type { Request, Response, NextFunction } from 'express';

export function requireTenant(req: Request, res: Response, next: NextFunction) {
  const user = (req as any).user as { schoolId: number } | undefined;
  const target = Number(req.params.schoolId ?? req.body.schoolId ?? req.query.schoolId ?? user?.schoolId);
  if (!user?.schoolId || !target || target !== user.schoolId) return res.status(403).json({ error: 'Wrong tenant' });
  (req as any).tenant = { schoolId: user.schoolId };
  next();
}
```

---

## src/server/middleware/rateLimit.ts
```ts
import type { Request, Response, NextFunction } from 'express';

const buckets = new Map<string, { count: number; resetAt: number }>();

export function rateLimit({ windowMs = 60_000, max = 30 }: { windowMs?: number; max?: number }) {
  return (req: Request, res: Response, next: NextFunction) => {
    const key = `${req.ip}:${req.path}`;
    const now = Date.now();
    const b = buckets.get(key);
    if (!b || now > b.resetAt) {
      buckets.set(key, { count: 1, resetAt: now + windowMs });
      return next();
    }
    if (b.count >= max) return res.status(429).json({ error: 'Too many requests' });
    b.count++;
    next();
  };
}
```

---

## src/server/services/users.ts
```ts
import { db } from '../db/client';
import { users, type Role } from '../db/schema';
import { eq } from 'drizzle-orm';
import bcrypt from 'bcryptjs';

export async function createUser(params: { email: string; password: string; role: Role; schoolId: number; active?: boolean; }) {
  const passwordHash = await bcrypt.hash(params.password, 10);
  const [row] = await db.insert(users).values({
    email: params.email.toLowerCase(),
    passwordHash,
    role: params.role,
    schoolId: params.schoolId,
    active: params.active ?? true
  }).returning();
  return row;
}

export async function findUserByEmailSchool(email: string, schoolId: number) {
  const [row] = await db.select().from(users).where(eq(users.email, email.toLowerCase())).where(eq(users.schoolId, schoolId));
  return row ?? null;
}
```

---

## src/server/services/schools.ts
```ts
import { db } from '../db/client';
import { schools } from '../db/schema';
import { eq } from 'drizzle-orm';

export async function createSchool(name: string, seatsAllowed = 50) {
  const [row] = await db.insert(schools).values({ name, seatsAllowed }).returning();
  return row;
}

export async function getSchoolById(id: number) {
  const [row] = await db.select().from(schools).where(eq(schools.id, id));
  return row ?? null;
}
```

---

## src/server/services/passes.ts
```ts
import { db } from '../db/client';
import { passes } from '../db/schema';
import { and, desc, eq, isNull } from 'drizzle-orm';

export async function createPass(params: { studentName: string; reason: string; issuedByUserId: number; schoolId: number; }) {
  const [row] = await db.insert(passes).values(params).returning();
  return row;
}

export async function listActivePasses(schoolId: number) {
  return db.select().from(passes).where(and(eq(passes.schoolId, schoolId), eq(passes.status, 'active'))).orderBy(desc(passes.startsAt));
}

export async function returnPass(id: number, schoolId: number) {
  const [row] = await db.update(passes).set({ status: 'returned', endsAt: new Date() }).where(and(eq(passes.id, id), eq(passes.schoolId, schoolId), eq(passes.status, 'active'))).returning();
  return row ?? null; // idempotent-ish: returns null if already returned or wrong school
}
```

---

## src/server/routes/public.ts
```ts
import { Router } from 'express';

export const publicRouter = Router();

publicRouter.get('/health', (_req, res) => {
  res.json({ ok: true, ts: Date.now() });
});
```

---

## src/server/routes/auth.ts
```ts
import { Router } from 'express';
import { asyncHandler } from '../middleware/asyncHandler';
import { setSession, clearSession } from '../middleware/auth';
import { findUserByEmailSchool } from '../services/users';
import bcrypt from 'bcryptjs';
import { rateLimit } from '../middleware/rateLimit';

export const authRouter = Router();

authRouter.post('/login', rateLimit({ windowMs: 60_000, max: 20 }), asyncHandler(async (req, res) => {
  const { email, password, schoolId } = req.body ?? {};
  if (!email || !password || !schoolId) return res.status(400).json({ error: 'Missing fields' });
  const user = await findUserByEmailSchool(String(email), Number(schoolId));
  if (!user || !user.active) return res.status(401).json({ error: 'Invalid credentials' });
  const ok = await bcrypt.compare(String(password), user.passwordHash);
  if (!ok) return res.status(401).json({ error: 'Invalid credentials' });
  setSession(res, { userId: user.id, schoolId: user.schoolId, role: user.role as any, iat: Date.now() });
  res.json({ ok: true });
}));

authRouter.post('/logout', asyncHandler(async (_req, res) => {
  clearSession(res);
  res.json({ ok: true });
}));

authRouter.get('/me', asyncHandler(async (req, res) => {
  const u = (req as any).user;
  res.json({ user: u ?? null });
}));
```

---

## src/server/routes/admin.ts
```ts
import { Router } from 'express';
import { asyncHandler } from '../middleware/asyncHandler';
import { requireAuth, requireRole } from '../middleware/auth';
import { createSchool } from '../services/schools';
import { createUser } from '../services/users';

export const adminRouter = Router();

adminRouter.use(requireAuth, requireRole('admin'));

adminRouter.post('/schools', asyncHandler(async (req, res) => {
  const { name, seatsAllowed } = req.body ?? {};
  if (!name) return res.status(400).json({ error: 'Missing name' });
  const s = await createSchool(String(name), seatsAllowed ? Number(seatsAllowed) : 50);
  res.json({ school: s });
}));

adminRouter.post('/users', asyncHandler(async (req, res) => {
  const { email, password, role, schoolId } = req.body ?? {};
  if (!email || !password || !role || !schoolId) return res.status(400).json({ error: 'Missing fields' });
  const u = await createUser({ email, password, role, schoolId: Number(schoolId) });
  res.json({ user: { id: u.id, email: u.email, role: u.role, schoolId: u.schoolId } });
}));
```

---

## src/server/routes/kiosk.ts
```ts
import { Router } from 'express';
import { asyncHandler } from '../middleware/asyncHandler';
import { rateLimit } from '../middleware/rateLimit';
import { createPass, returnPass, listActivePasses } from '../services/passes';

// Minimal kiosk cookie using same session shape but flagged as kiosk
import { setSession, readSession } from '../middleware/auth';

export const kioskRouter = Router();

kioskRouter.post('/login', rateLimit({ windowMs: 60_000, max: 30 }), asyncHandler(async (req, res) => {
  const { schoolId, room, pin } = req.body ?? {};
  if (!schoolId || !room || !pin) return res.status(400).json({ error: 'Missing fields' });
  // TODO: verify pin against kioskDevices (pinHash) for that school/room
  // For starter, accept any non-empty PIN (replace when schema seeded)
  setSession(res, { userId: 0, schoolId: Number(schoolId), role: 'teacher', iat: Date.now() });
  res.json({ ok: true });
}));

kioskRouter.post('/passes', rateLimit({ windowMs: 10_000, max: 12 }), asyncHandler(async (req, res) => {
  const s = readSession(req);
  if (!s) return res.status(401).json({ error: 'Unauthorized' });
  const { studentName, reason, issuedByUserId } = req.body ?? {};
  if (!studentName || !reason || !issuedByUserId) return res.status(400).json({ error: 'Missing fields' });
  const p = await createPass({ studentName, reason, issuedByUserId: Number(issuedByUserId), schoolId: s.schoolId });
  res.json({ pass: p });
}));

kioskRouter.patch('/passes/:id/return', asyncHandler(async (req, res) => {
  const s = readSession(req);
  if (!s) return res.status(401).json({ error: 'Unauthorized' });
  const p = await returnPass(Number(req.params.id), s.schoolId);
  res.json({ pass: p, ok: !!p });
}));

kioskRouter.get('/passes/active', asyncHandler(async (req, res) => {
  const s = readSession(req);
  if (!s) return res.status(401).json({ error: 'Unauthorized' });
  const list = await listActivePasses(s.schoolId);
  res.json({ passes: list });
}));
```

---

## src/server/routes/passes.ts
```ts
import { Router } from 'express';
import { asyncHandler } from '../middleware/asyncHandler';
import { requireAuth } from '../middleware/auth';
import { createPass, listActivePasses, returnPass } from '../services/passes';

export const passesRouter = Router();

passesRouter.use(requireAuth);

passesRouter.get('/', asyncHandler(async (req, res) => {
  const { schoolId, userId } = (req as any).user;
  const list = await listActivePasses(schoolId);
  res.json({ passes: list });
}));

passesRouter.post('/', asyncHandler(async (req, res) => {
  const { schoolId, userId } = (req as any).user;
  const { studentName, reason } = req.body ?? {};
  if (!studentName || !reason) return res.status(400).json({ error: 'Missing fields' });
  const p = await createPass({ studentName, reason, issuedByUserId: userId, schoolId });
  res.json({ pass: p });
}));

passesRouter.patch('/:id/return', asyncHandler(async (req, res) => {
  const { schoolId } = (req as any).user;
  const p = await returnPass(Number(req.params.id), schoolId);
  res.json({ pass: p, ok: !!p });
}));
```

---

## src/server/routes/sa.ts (Phase 5.5 minimal)
```ts
import { Router } from 'express';
import { asyncHandler } from '../middleware/asyncHandler';
import { requireAuth, requireRole } from '../middleware/auth';
import { createSchool } from '../services/schools';
import { createUser } from '../services/users';

export const saRouter = Router();
saRouter.use(requireAuth, requireRole('superadmin'));

saRouter.get('/health', asyncHandler(async (_req, res) => {
  res.json({ ok: true, ts: Date.now() });
}));

saRouter.post('/schools', asyncHandler(async (req, res) => {
  const { name, seatsAllowed } = req.body ?? {};
  if (!name) return res.status(400).json({ error: 'Missing name' });
  const school = await createSchool(String(name), seatsAllowed ? Number(seatsAllowed) : 50);
  res.json({ school });
}));

saRouter.post('/users', asyncHandler(async (req, res) => {
  const { email, password, role, schoolId } = req.body ?? {};
  if (!email || !password || !role || !schoolId) return res.status(400).json({ error: 'Missing fields' });
  const user = await createUser({ email, password, role, schoolId: Number(schoolId) });
  res.json({ user });
}));
```

---

## src/server/index.ts
```ts
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import { cookies } from './middleware/auth';
import { notFound, errorHandler } from './middleware/error';
import { publicRouter } from './routes/public';
import { authRouter } from './routes/auth';

const app = express();
app.set('trust proxy', 1);
app.use(helmet());
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(cookies(process.env.SESSION_SECRET!));

// Core Slim mounts only
app.use('/', publicRouter);
app.use('/', authRouter);

// Later, re-enable these when ready:
// import { adminRouter } from './routes/admin';
// import { passesRouter } from './routes/passes';
// import { kioskRouter } from './routes/kiosk';
// import { saRouter } from './routes/sa';
// app.use('/admin', adminRouter);
// app.use('/passes', passesRouter);
// app.use('/kiosk', kioskRouter);
// app.use('/sa', saRouter);

app.use(notFound);
app.use(errorHandler);

const port = Number(process.env.PORT || 3000);
app.listen(port, () => {
  console.log(`PassPilot (Core Slim) running on http://localhost:${port}`);
});
```ts
import 'dotenv/config';
import express from 'express';
import helmet from 'helmet';
import { cookies } from './middleware/auth';
import { notFound, errorHandler } from './middleware/error';
import { publicRouter } from './routes/public';
import { authRouter } from './routes/auth';
import { adminRouter } from './routes/admin';
import { passesRouter } from './routes/passes';
import { kioskRouter } from './routes/kiosk';
import { saRouter } from './routes/sa';

const app = express();
app.set('trust proxy', 1);
app.use(helmet());
app.use(express.json({ limit: '1mb' }));
app.use(express.urlencoded({ extended: true }));
app.use(cookies(process.env.SESSION_SECRET!));

app.use('/', publicRouter);
app.use('/', authRouter);
app.use('/admin', adminRouter);
app.use('/passes', passesRouter);
app.use('/kiosk', kioskRouter);
app.use('/sa', saRouter);

app.use(notFound);
app.use(errorHandler);

const port = Number(process.env.PORT || 3000);
app.listen(port, () => {
  console.log(`PassPilot starter running on http://localhost:${port}`);
});
```

---

## src/scripts/seed.ts
```ts
import 'dotenv/config';
import { db } from '../server/db/client';
import { createSchool } from '../server/services/schools';
import { createUser } from '../server/services/users';

async function main() {
  const school = await createSchool('Demo School', 20);
  const admin = await createUser({ email: 'admin@demo.edu', password: 'admin123', role: 'admin', schoolId: school.id });
  const teacher = await createUser({ email: 'teacher@demo.edu', password: 'teacher123', role: 'teacher', schoolId: school.id });
  const superadmin = await createUser({ email: 'sa@passpilot.io', password: 'super123', role: 'superadmin', schoolId: school.id });
  console.log({ school, admin: { id: admin.id }, teacher: { id: teacher.id }, superadmin: { id: superadmin.id } });
}

main().then(() => process.exit(0)).catch((e) => { console.error(e); process.exit(1); });
```

---

# Quick start (Replit)
**Core Slim steps**
1. Add **Secrets**: `DATABASE_URL`, `SESSION_SECRET`, `NODE_ENV=production`.
2. `npm i`
3. `npm run db:generate && npm run db:migrate`
4. `npm run seed`
5. `npm run dev`

**Test:**
- `POST /login` with `{ email:"admin@demo.edu", password:"admin123", schoolId: <ID from seed> }` → `{ ok:true }` + cookie.
- `GET /me` → returns session.
- `POST /logout` → clears cookie; `/me` now 401.

**When ready to expand:**
- Uncomment the imports and `app.use(...)` lines in `index.ts`.
- Copy the corresponding router files (`admin.ts`, `passes.ts`, `kiosk.ts`, `sa.ts`).
- Add `requireTenant` + `rateLimit` middleware where noted.

**Test:**
- `POST /login` with `{ email:"admin@demo.edu", password:"admin123", schoolId: <ID from seed> }` → returns `{ ok:true }` and sets cookie.
- `GET /me` → returns user session.
- `POST /passes` as teacher → creates pass.
- `POST /kiosk/login` → (stubbed) sets kiosk session; create/return passes.

> Replace the stubbed kiosk PIN check with a real lookup in `kiosk_devices` once you add the seed for a device.


---

## v2 Registration — Drizzle schema additions (`src/server/db/schema.ts`)
```ts
import { pgTable, serial, varchar, boolean, integer, timestamp, text } from 'drizzle-orm/pg-core';
// ...existing imports and tables

export const registrationTokens = pgTable('registration_tokens', {
  id: serial('id').primaryKey(),
  schoolId: integer('school_id').references(() => schools.id).notNull(),
  email: varchar('email', { length: 255 }).notNull(),
  role: varchar('role', { length: 20 }).notNull(), // 'teacher' | 'admin'
  codeHash: varchar('code_hash', { length: 255 }).notNull(),
  expiresAt: timestamp('expires_at', { withTimezone: true }).notNull(),
  usedAt: timestamp('used_at', { withTimezone: true }),
  createdByUserId: integer('created_by_user_id').references(() => users.id).notNull(),
  createdAt: timestamp('created_at', { withTimezone: true }).defaultNow().notNull()
});
```
> Run: `npm run db:generate && npm run db:migrate`

---

## Registration utilities (`src/server/utils/registration.ts`)
```ts
import bcrypt from 'bcryptjs';

export function generateCode(len = 8) {
  const alphabet = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; // no O/0/1/I
  let raw = '';
  for (let i = 0; i < len; i++) raw += alphabet[Math.floor(Math.random() * alphabet.length)];
  // format like XXXX-XXXX for readability
  return raw.slice(0,4) + '-' + raw.slice(4);
}

export async function hashCode(code: string) {
  return bcrypt.hash(code, 10);
}

export async function verifyCode(code: string, hash: string) {
  return bcrypt.compare(code, hash);
}
```

---

## Registration service (`src/server/services/registration.ts`)
```ts
import { db } from '../db/client';
import { registrationTokens, users } from '../db/schema';
import { and, eq, gt, isNull } from 'drizzle-orm';
import { hashCode, verifyCode } from '../utils/registration';
import bcrypt from 'bcryptjs';

export async function createInvite(params: {
  email: string; role: 'teacher' | 'admin'; schoolId: number; expiresInMinutes?: number; createdByUserId: number;
}) {
  const expires = new Date(Date.now() + (params.expiresInMinutes ?? 1440) * 60 * 1000);
  const codeRaw = require('crypto').randomBytes(8).toString('base64url').replace(/[^A-Z0-9]/gi,'').slice(0,8).toUpperCase();
  const code = codeRaw.slice(0,4) + '-' + codeRaw.slice(4);
  const codeHash = await hashCode(code);
  const [row] = await db.insert(registrationTokens).values({
    schoolId: params.schoolId,
    email: params.email.toLowerCase(),
    role: params.role,
    codeHash,
    expiresAt: expires,
    createdByUserId: params.createdByUserId
  }).returning();
  return { token: row, code }; // return plaintext code to the admin once
}

export async function redeemInvite(params: { email: string; schoolId: number; code: string; password: string }) {
  const now = new Date();
  const [tok] = await db.select().from(registrationTokens).where(and(
    eq(registrationTokens.email, params.email.toLowerCase()),
    eq(registrationTokens.schoolId, params.schoolId),
    isNull(registrationTokens.usedAt),
    gt(registrationTokens.expiresAt, now)
  )).limit(1);
  if (!tok) return { ok: false as const, reason: 'invalid_or_expired' };
  const ok = await verifyCode(params.code, tok.codeHash);
  if (!ok) return { ok: false as const, reason: 'invalid_or_expired' };

  // ensure user doesn't already exist
  const exists = await db.select({ id: users.id }).from(users).where(and(
    eq(users.email, params.email.toLowerCase()),
    eq(users.schoolId, params.schoolId)
  )).limit(1);
  if (exists.length) return { ok: false as const, reason: 'already_exists' };

  const passwordHash = await bcrypt.hash(params.password, 10);
  const [u] = await db.insert(users).values({
    email: params.email.toLowerCase(),
    passwordHash,
    role: tok.role as any,
    schoolId: params.schoolId,
    active: true
  }).returning();

  await db.update(registrationTokens).set({ usedAt: now }).where(eq(registrationTokens.id, tok.id));
  return { ok: true as const, user: u };
}
```

---

## Admin invite endpoint (`src/server/routes/admin.ts`) — add below existing routes
```ts
import { createInvite } from '../services/registration';
import { requireTenant } from '../middleware/tenant';

// Ensure this router already uses: requireAuth + requireRole('admin')

adminRouter.post('/invites', requireTenant, asyncHandler(async (req, res) => {
  const { email, role, expiresInMinutes } = req.body ?? {};
  const { schoolId, userId } = (req as any).user;
  if (!email || !role) return res.status(400).json({ error: 'Missing fields' });
  if (!['teacher','admin'].includes(String(role))) return res.status(400).json({ error: 'Invalid role' });

  const { token, code } = await createInvite({
    email: String(email),
    role: role as 'teacher'|'admin',
    schoolId,
    expiresInMinutes: expiresInMinutes ? Number(expiresInMinutes) : 1440,
    createdByUserId: userId
  });

  const activationUrl = `/activate?schoolId=${schoolId}&email=${encodeURIComponent(String(email).toLowerCase())}`;
  res.json({ ok: true, activationUrl, code, expiresAt: token.expiresAt });
}));
```

---

## Public activation endpoint (`src/server/routes/public.ts`) — add to public router
```ts
import { redeemInvite } from '../services/registration';
import { setSession } from '../middleware/auth';

publicRouter.post('/activate', asyncHandler(async (req, res) => {
  const { email, schoolId, code, password } = req.body ?? {};
  if (!email || !schoolId || !code || !password) return res.status(400).json({ error: 'Missing fields' });
  const result = await redeemInvite({
    email: String(email),
    schoolId: Number(schoolId),
    code: String(code).toUpperCase().trim(),
    password: String(password)
  });
  if (!result.ok) return res.status(410).json({ error: result.reason });
  setSession(res, { userId: result.user.id, schoolId: result.user.schoolId, role: result.user.role as any, iat: Date.now() });
  res.json({ ok: true });
}));
```

---

## Minimal activation page (optional) — `src/web/views/activate.ejs`
```ejs
<!doctype html>
<html>
  <head><meta charset="utf-8"><title>Activate Account</title></head>
  <body>
    <h1>Activate your account</h1>
    <form method="post" action="/activate">
      <input type="hidden" name="schoolId" value="<%= schoolId || '' %>">
      <label>Email <input name="email" type="email" value="<%= email || '' %>" required></label><br>
      <label>Code <input name="code" type="text" placeholder="XXXX-XXXX" required></label><br>
      <label>New password <input name="password" type="password" required></label><br>
      <button type="submit">Activate</button>
    </form>
  </body>
</html>
```

Add a simple route to render it (optional):
```ts
publicRouter.get('/activate', (req, res) => {
  res.setHeader('Content-Type','text/html');
  const html = `<!doctype html><html><body>
  <form method="post" action="/activate">
    <input type="hidden" name="schoolId" value="${Number(req.query.schoolId||'')||''}">
    <input name="email" type="email" value="${(req.query.email||'')}">
    <input name="code" placeholder="XXXX-XXXX">
    <input name="password" type="password" placeholder="New password">
    <button>Activate</button>
  </form></body></html>`;
  res.end(html);
});
```

---

## Security & rate limits (add now)
```ts
// In auth/public router files
import { rateLimit } from '../middleware/rateLimit';

// Limit invite creation
adminRouter.post('/invites', rateLimit({ windowMs: 60_000, max: 10 }), /* ... */);

// Limit activation attempts
publicRouter.post('/activate', rateLimit({ windowMs: 60_000, max: 15 }), /* ... */);
```

**Notes**
- Store/compare **emails in lowercase**.
- Keep invites **single-use** (`usedAt` set on success).
- Short TTLs (default 24h); you can pass `expiresInMinutes` to shorten.
- Never trust client `schoolId` for role; we take role and school from the server-side token.
